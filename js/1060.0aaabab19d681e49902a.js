"use strict";(self.webpackChunksandbox=self.webpackChunksandbox||[]).push([[1060],{5140:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(4025),r=function(){return r=Object.assign||function(t){for(var e,n=1,o=arguments.length;n<o;n++)for(var r in e=arguments[n])Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t},r.apply(this,arguments)};const s=function(t){var e,n=(0,o.useScalprum)(),s=(null===(e=n.api)||void 0===e?void 0:e.chrome)||{};return s=r(r({},s),{initialized:n.initialized}),"function"==typeof t?t(s):s}},8483:(t,e,n)=>{n.d(e,{Dv:()=>l,b9:()=>d});var o=n(8416),r=n.n(o),s=n(9726);const i=(0,o.createContext)(void 0),a=t=>{const e=(0,o.useContext)(i);return(null==t?void 0:t.store)||e||(0,s.K7)()},u=t=>"function"==typeof(null==t?void 0:t.then),c=r().use||(t=>{if("pending"===t.status)throw t;if("fulfilled"===t.status)return t.value;throw"rejected"===t.status?t.reason:(t.status="pending",t.then((e=>{t.status="fulfilled",t.value=e}),(e=>{t.status="rejected",t.reason=e})),t)});function l(t,e){const n=a(e),[[r,s,i],l]=(0,o.useReducer)((e=>{const o=n.get(t);return Object.is(e[0],o)&&e[1]===n&&e[2]===t?e:[o,n,t]}),void 0,(()=>[n.get(t),n,t]));let d=r;s===n&&i===t||(l(),d=n.get(t));const f=null==e?void 0:e.delay;return(0,o.useEffect)((()=>{const e=n.sub(t,(()=>{"number"!=typeof f?l():setTimeout(l,f)}));return l(),e}),[n,t,f]),(0,o.useDebugValue)(d),u(d)?c(d):d}function d(t,e){const n=a(e);return(0,o.useCallback)(((...e)=>{if(!("write"in t))throw new Error("not writable atom");return n.set(t,...e)}),[n,t])}},9726:(t,e,n)=>{n.d(e,{K7:()=>m,cn:()=>r});let o=0;function r(t,e){const n="atom"+ ++o,r={toString:()=>n};return"function"==typeof t?r.read=t:(r.init=t,r.read=s,r.write=i),e&&(r.write=e),r}function s(t){return t(this)}function i(t,e,n){return e(this,"function"==typeof n?n(t(this)):n)}const a=(t,e)=>t.unstable_is?t.unstable_is(e):e===t,u=t=>"init"in t,c=t=>!!t.write,l=new WeakMap,d=(t,e)=>{const n=l.get(t);n&&(l.delete(t),n(e))},f=(t,e)=>{t.status="fulfilled",t.value=e},h=(t,e)=>{t.status="rejected",t.reason=e},v=(t,e)=>!!t&&"v"in t&&"v"in e&&Object.is(t.v,e.v),w=(t,e)=>!!t&&"e"in t&&"e"in e&&Object.is(t.e,e.e),g=t=>!!t&&"v"in t&&t.v instanceof Promise,_=t=>{if("e"in t)throw t.e;return t.v},p=()=>{const t=new WeakMap,e=new WeakMap,n=new Map;let o,r;o=new Set,r=new Set;const s=e=>t.get(e),i=(e,o)=>{Object.freeze(o);const r=s(e);if(t.set(e,o),n.has(e)||n.set(e,r),g(r)){const t="v"in o?o.v instanceof Promise?o.v:Promise.resolve(o.v):Promise.reject(o.e);r.v!==t&&d(r.v,t)}},p=(t,e,n,o)=>{const r=new Map(o?e.d:null);let s=!1;n.forEach(((n,o)=>{!n&&a(t,o)&&(n=e),n?(r.set(o,n),e.d.get(o)!==n&&(s=!0)):console.warn("[Bug] atom state not found")})),(s||e.d.size!==r.size)&&(e.d=r)},b=(t,e,n,o)=>{const r=s(t),a={d:(null==r?void 0:r.d)||new Map,v:e};if(n&&p(t,a,n,o),v(r,a)&&r.d===a.d)return r;if(g(r)&&g(a)&&(c=a,"v"in(u=r)&&"v"in c&&u.v.orig&&u.v.orig===c.v.orig)){if(r.d===a.d)return r;a.v=r.v}var u,c;return i(t,a),a},m=(t,n,o,r)=>{if("function"==typeof(null==(i=n)?void 0:i.then)){let i;const a=()=>{const n=s(t);if(!g(n)||n.v!==u)return;const r=b(t,u,o);e.has(t)&&n.d!==r.d&&N(t,r,n.d)},u=new Promise(((t,e)=>{let o=!1;n.then((e=>{o||(o=!0,f(u,e),t(e),a())}),(t=>{o||(o=!0,h(u,t),e(t),a())})),i=e=>{o||(o=!0,e.then((t=>f(u,t)),(t=>h(u,t))),t(e))}}));return u.orig=n,u.status="pending",((t,e)=>{l.set(t,(t=>{t&&i(t),null==r||r()})),t.catch((()=>{})).finally((()=>l.delete(t)))})(u),b(t,u,o,!0)}var i;return b(t,n,o)},y=(t,n)=>{const o=s(t);if(!n&&o){if(e.has(t))return o;if(Array.from(o.d).every((([e,n])=>{if(e===t)return!0;const o=y(e);return o===n||v(o,n)})))return o}const r=new Map;let l=!0;const d=e=>{if(a(t,e)){const t=s(e);if(t)return r.set(e,t),_(t);if(u(e))return r.set(e,void 0),e.init;throw new Error("no atom init")}const n=y(e);return r.set(e,n),_(n)};let f,h;const g={get signal(){return f||(f=new AbortController),f.signal},get setSelf(){return c(t)||console.warn("setSelf function cannot be used with read-only atom"),!h&&c(t)&&(h=(...e)=>{if(l&&console.warn("setSelf function cannot be called in sync"),!l)return M(t,...e)}),h}};try{const e=t.read(d,g);return m(t,e,r,(()=>null==f?void 0:f.abort()))}catch(e){return((t,e,n)=>{const o=s(t),r={d:(null==o?void 0:o.d)||new Map,e};return n&&p(t,r,n),w(o,r)&&o.d===r.d?o:(i(t,r),r)})(t,e,r)}finally{l=!1}},E=(t,e)=>!e.l.size&&(!e.t.size||1===e.t.size&&e.t.has(t)),S=t=>{const o=new Array,r=new Set,i=t=>{if(!r.has(t)){r.add(t);for(const o of(t=>{var o;const r=new Set(null==(o=e.get(t))?void 0:o.t);return n.forEach(((e,n)=>{var o;(null==(o=s(n))?void 0:o.d.has(t))&&r.add(n)})),r})(t))t!==o&&i(o);o.push(t)}};i(t);const a=new Set([t]);for(let t=o.length-1;t>=0;--t){const e=o[t],n=s(e);if(!n)continue;let r=!1;for(const t of n.d.keys())if(t!==e&&a.has(t)){r=!0;break}if(r){const t=y(e,!0);v(n,t)||a.add(e)}}},O=(t,...e)=>{let n=!0;const r=t.write((t=>_(y(t))),((e,...r)=>{let i;if(a(t,e)){if(!u(e))throw new Error("atom not writable");const t=s(e),n=m(e,r[0]);v(t,n)||S(e)}else i=O(e,...r);if(!n){const t=j();o.forEach((e=>e({type:"async-write",flushed:t})))}return i}),...e);return n=!1,r},M=(t,...e)=>{const n=O(t,...e),r=j();return o.forEach((t=>t({type:"write",flushed:r}))),n},T=(t,n,o)=>{var i;const a=o||[];null==(i=s(t))||i.d.forEach(((n,o)=>{const r=e.get(o);r?r.t.add(t):o!==t&&T(o,t,a)})),y(t);const u={t:new Set(n&&[n]),l:new Set};if(e.set(t,u),r.add(t),c(t)&&t.onMount){const{onMount:e}=t;a.push((()=>{const n=e(((...e)=>M(t,...e)));n&&(u.u=n)}))}return o||a.forEach((t=>t())),u},A=t=>{var n;const o=null==(n=e.get(t))?void 0:n.u;o&&o(),e.delete(t),r.delete(t);const i=s(t);i?(g(i)&&d(i.v),i.d.forEach(((n,o)=>{if(o!==t){const n=e.get(o);n&&(n.t.delete(t),E(o,n)&&A(o))}}))):console.warn("[Bug] could not find atom state to unmount",t)},N=(t,n,o)=>{const r=new Set(n.d.keys()),s=new Set;null==o||o.forEach(((n,o)=>{if(r.has(o))return void r.delete(o);s.add(o);const i=e.get(o);i&&i.t.delete(t)})),r.forEach((n=>{const o=e.get(n);o?o.t.add(t):e.has(t)&&T(n,t)})),s.forEach((t=>{const n=e.get(t);n&&E(t,n)&&A(t)}))},j=()=>{let t;for(t=new Set;n.size;){const o=Array.from(n);n.clear(),o.forEach((([n,o])=>{const r=s(n);if(r){const s=e.get(n);s&&r.d!==(null==o?void 0:o.d)&&N(n,r,null==o?void 0:o.d),s&&(g(o)||!v(o,r)&&!w(o,r))&&(s.l.forEach((t=>t())),t.add(n))}else console.warn("[Bug] no atom state to flush")}))}return t};return{get:t=>_(y(t)),set:M,sub:(t,n)=>{const r=(t=>{let n=e.get(t);return n||(n=T(t)),n})(t),s=j(),i=r.l;return i.add(n),o.forEach((t=>t({type:"sub",flushed:s}))),()=>{i.delete(n),(t=>{const n=e.get(t);n&&E(t,n)&&A(t)})(t),o.forEach((t=>t({type:"unsub"})))}},dev_subscribe_store:(t,e)=>{if(2!==e)throw new Error("The current StoreListener revision is 2.");return o.add(t),()=>{o.delete(t)}},dev_get_mounted_atoms:()=>r.values(),dev_get_atom_state:e=>t.get(e),dev_get_mounted:t=>e.get(t),dev_restore_atoms:t=>{for(const[e,n]of t)u(e)&&(m(e,n),S(e));const e=j();o.forEach((t=>t({type:"restore",flushed:e})))}}};let b;"number"==typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__?++globalThis.__NUMBER_OF_JOTAI_INSTANCES__:globalThis.__NUMBER_OF_JOTAI_INSTANCES__=1;const m=()=>(b||(1!==globalThis.__NUMBER_OF_JOTAI_INSTANCES__&&console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"),b=p()),b)}}]);
//# sourceMappingURL=../sourcemaps/1060.0b131fc06f2d97e653a00ad105f4fb89.js.map