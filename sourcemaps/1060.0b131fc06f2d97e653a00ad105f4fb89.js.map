{"version":3,"file":"js/1060.xxxxxxxxxxxxxxxxxxxx.js","mappings":"iIAAIA,EAAsC,WAStC,OARAA,EAAWC,OAAOC,QAAU,SAASC,GACjC,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAII,KADTL,EAAIG,UAAUF,GACOJ,OAAOS,UAAUC,eAAeC,KAAKR,EAAGK,KACzDN,EAAEM,GAAKL,EAAEK,IAEjB,OAAON,CACX,EACOH,EAASa,MAAMC,KAAMP,UAChC,EAYA,QAVgB,SAAUQ,GACtB,IAAIC,EACAC,GAAQ,IAAAC,eACRC,GAA+B,QAApBH,EAAKC,EAAMG,WAAwB,IAAPJ,OAAgB,EAASA,EAAGG,SAAW,CAAC,EAEnF,OADAA,EAASnB,EAASA,EAAS,CAAC,EAAGmB,GAAS,CAAEE,YAAaJ,EAAMI,cACrC,mBAAbN,EACAA,EAASI,GAEbA,CACX,C,6ECjBA,MAAMG,GAAe,IAAAC,oBAAc,GAC7BC,EAAYC,IAChB,MAAMC,GAAQ,IAAAC,YAAWL,GACzB,OAAmB,MAAXG,OAAkB,EAASA,EAAQC,QAAUA,IAAS,SAAiB,EAmB3EE,EAAiBC,GAA+C,mBAA5B,MAALA,OAAY,EAASA,EAAEC,MACtDC,EAAM,SAAoB,CAAEC,IAChC,GAAuB,YAAnBA,EAAQC,OACV,MAAMD,EACD,GAAuB,cAAnBA,EAAQC,OACjB,OAAOD,EAAQE,MACV,KAAuB,aAAnBF,EAAQC,OACXD,EAAQG,QAEdH,EAAQC,OAAS,UACjBD,EAAQF,MACLM,IACCJ,EAAQC,OAAS,YACjBD,EAAQE,MAAQE,CAAC,IAElBC,IACCL,EAAQC,OAAS,WACjBD,EAAQG,OAASE,CAAC,IAGhBL,EAET,GACD,SAASM,EAAaC,EAAMd,GAC1B,MAAMC,EAAQF,EAASC,KACfe,EAAkBC,EAAkBC,GAAkBC,IAAY,IAAAC,aACvEC,IACC,MAAMC,EAAYpB,EAAMqB,IAAIR,GAC5B,OAAItC,OAAO+C,GAAGH,EAAK,GAAIC,IAAcD,EAAK,KAAOnB,GAASmB,EAAK,KAAON,EAC7DM,EAEF,CAACC,EAAWpB,EAAOa,EAAK,QAEjC,GACA,IAAM,CAACb,EAAMqB,IAAIR,GAAOb,EAAOa,KAEjC,IAAIL,EAAQM,EACRC,IAAqBf,GAASgB,IAAoBH,IACpDI,IACAT,EAAQR,EAAMqB,IAAIR,IAEpB,MAAMU,EAAmB,MAAXxB,OAAkB,EAASA,EAAQwB,MAajD,OAZA,IAAAC,YAAU,KACR,MAAMC,EAAQzB,EAAM0B,IAAIb,GAAM,KACP,iBAAVU,EAIXN,IAHEU,WAAWV,EAAUM,EAGb,IAGZ,OADAN,IACOQ,CAAK,GACX,CAACzB,EAAOa,EAAMU,KACjB,IAAAK,eAAcpB,GACPN,EAAcM,GAASH,EAAIG,GAASA,CAC7C,CAEA,SAASqB,EAAWhB,EAAMd,GACxB,MAAMC,EAAQF,EAASC,GAUvB,OATgB,IAAA+B,cACd,IAAIC,KACF,KAA4E,UAAWlB,GACrF,MAAM,IAAImB,MAAM,qBAElB,OAAOhC,EAAMiC,IAAIpB,KAASkB,EAAK,GAEjC,CAAC/B,EAAOa,GAGZ,C,4CC/FA,IAAIqB,EAAW,EACf,SAASrB,EAAKsB,EAAMC,GAClB,MAAMC,EAAM,UAASH,EACfI,EAAS,CACbC,SAAU,IAAMF,GAYlB,MAVoB,mBAATF,EACTG,EAAOH,KAAOA,GAEdG,EAAOE,KAAOL,EACdG,EAAOH,KAAOM,EACdH,EAAOF,MAAQM,GAEbN,IACFE,EAAOF,MAAQA,GAEVE,CACT,CACA,SAASG,EAAYpB,GACnB,OAAOA,EAAIjC,KACb,CACA,SAASsD,EAAarB,EAAKY,EAAKU,GAC9B,OAAOV,EACL7C,KACe,mBAARuD,EAAqBA,EAAItB,EAAIjC,OAASuD,EAEjD,CAEA,MAAMC,EAAa,CAAC/B,EAAMgC,IAAMhC,EAAKiC,YAAcjC,EAAKiC,YAAYD,GAAKA,IAAMhC,EACzEkC,EAAmBlC,GAAS,SAAUA,EACtCmC,EAA0BnC,KAAWA,EAAKuB,MAC1Ca,EAAmC,IAAIC,QAMvCC,EAAgB,CAAC7C,EAAS8C,KAC9B,MAAMC,EAASJ,EAAiB5B,IAAIf,GAChC+C,IACFJ,EAAiBK,OAAOhD,GACxB+C,EAAOD,GACT,EAEIG,EAAiB,CAACjD,EAASE,KAC/BF,EAAQC,OAAS,YACjBD,EAAQE,MAAQA,CAAK,EAEjBgD,EAAgB,CAAClD,EAASK,KAC9BL,EAAQC,OAAS,WACjBD,EAAQG,OAASE,CAAC,EAGd8C,EAAmB,CAACZ,EAAGa,MAAQb,GAAK,MAAOA,GAAK,MAAOa,GAAKnF,OAAO+C,GAAGuB,EAAEnC,EAAGgD,EAAEhD,GAC7EiD,EAAmB,CAACd,EAAGa,MAAQb,GAAK,MAAOA,GAAK,MAAOa,GAAKnF,OAAO+C,GAAGuB,EAAElC,EAAG+C,EAAE/C,GAC7EiD,EAAuBf,KAAQA,GAAK,MAAOA,GAAKA,EAAEnC,aAAamD,QAE/DC,EAAmBC,IACvB,GAAI,MAAOA,EACT,MAAMA,EAAUpD,EAElB,OAAOoD,EAAUrD,CAAC,EAEdsD,EAAc,KAClB,MAAMC,EAA+B,IAAIf,QACnCgB,EAA6B,IAAIhB,QACjCiB,EAA6B,IAAIC,IACvC,IAAIC,EACAC,EAEFD,EAAqC,IAAIE,IACzCD,EAA+B,IAAIC,IAErC,MAAMC,EAAgB3D,GAASoD,EAAa5C,IAAIR,GAC1C4D,EAAe,CAAC5D,EAAMkD,KAExBxF,OAAOmG,OAAOX,GAEhB,MAAMY,EAAgBH,EAAa3D,GAKnC,GAJAoD,EAAahC,IAAIpB,EAAMkD,GAClBI,EAAWS,IAAI/D,IAClBsD,EAAWlC,IAAIpB,EAAM8D,GAEnBf,EAAoBe,GAAgB,CACtC,MAAMvB,EAAO,MAAOW,EAAYA,EAAUrD,aAAamD,QAAUE,EAAUrD,EAAImD,QAAQgB,QAAQd,EAAUrD,GAAKmD,QAAQiB,OAAOf,EAAUpD,GACnIgE,EAAcjE,IAAM0C,GACtBD,EAAcwB,EAAcjE,EAAG0C,EAEnC,GAEI2B,EAAqB,CAAClE,EAAMmE,EAAeC,EAAkBC,KACjE,MAAMC,EAAe,IAAIf,IACvBc,EAA2BF,EAAcI,EAAI,MAE/C,IAAIC,GAAU,EACdJ,EAAiBK,SAAQ,CAACC,EAAQ1C,MAC3B0C,GAAU3C,EAAW/B,EAAMgC,KAC9B0C,EAASP,GAEPO,GACFJ,EAAalD,IAAIY,EAAG0C,GAChBP,EAAcI,EAAE/D,IAAIwB,KAAO0C,IAC7BF,GAAU,IAGZG,QAAQC,KAAK,6BACf,KAEEJ,GAAWL,EAAcI,EAAEM,OAASP,EAAaO,QACnDV,EAAcI,EAAID,EACpB,EAEIQ,EAAe,CAAC9E,EAAML,EAAOyE,EAAkBC,KACnD,MAAMP,EAAgBH,EAAa3D,GAC7BmE,EAAgB,CACpBI,GAAqB,MAAjBT,OAAwB,EAASA,EAAcS,IAAsB,IAAIhB,IAC7E1D,EAAGF,GAUL,GARIyE,GACFF,EACElE,EACAmE,EACAC,EACAC,GAGAzB,EAAiBkB,EAAeK,IAAkBL,EAAcS,IAAMJ,EAAcI,EACtF,OAAOT,EAET,GAAIf,EAAoBe,IAAkBf,EAAoBoB,KAzE9BtB,EAyEuFsB,EAzEjF,MAATnC,EAyE2E8B,IAzEtD,MAAOjB,GAAKb,EAAEnC,EAAEkF,MAAQ/C,EAAEnC,EAAEkF,OAASlC,EAAEhD,EAAEkF,MAyE4C,CACrI,GAAIjB,EAAcS,IAAMJ,EAAcI,EACpC,OAAOT,EAEPK,EAActE,EAAIiE,EAAcjE,CAEpC,CA/E4B,IAACmC,EAAGa,EAiFhC,OADAe,EAAa5D,EAAMmE,GACZA,CAAa,EAEhBa,EAAwB,CAAChF,EAAMiF,EAAgBb,EAAkBc,KACrE,GAxFkE,mBAA5B,OAAnB5F,EAwFD2F,QAxF2B,EAAS3F,EAAEC,MAwFrB,CACjC,IAAI4F,EACJ,MAAMC,EAA4B,KAChC,MAAMtB,EAAgBH,EAAa3D,GACnC,IAAK+C,EAAoBe,IAAkBA,EAAcjE,IAAMJ,EAC7D,OAEF,MAAM0E,EAAgBW,EACpB9E,EACAP,EACA2E,GAEEf,EAAWU,IAAI/D,IAAS8D,EAAcS,IAAMJ,EAAcI,GAC5Dc,EAAkBrF,EAAMmE,EAAeL,EAAcS,EACvD,EAEI9E,EAAU,IAAIuD,SAAQ,CAACgB,EAASC,KACpC,IAAIqB,GAAU,EACdL,EAAe1F,MACZM,IACMyF,IACHA,GAAU,EACV5C,EAAejD,EAASI,GACxBmE,EAAQnE,GACRuF,IACF,IAEDtF,IACMwF,IACHA,GAAU,EACV3C,EAAclD,EAASK,GACvBmE,EAAOnE,GACPsF,IACF,IAGJD,EAAmB5C,IACZ+C,IACHA,GAAU,EACV/C,EAAKhD,MACFM,GAAM6C,EAAejD,EAASI,KAC9BC,GAAM6C,EAAclD,EAASK,KAEhCkE,EAAQzB,GACV,CACD,IAUH,OARA9C,EAAQsF,KAAOE,EACfxF,EAAQC,OAAS,UA5JO,EAACD,EAAS+C,KACtCJ,EAAiBhB,IAAI3B,GA4Je8C,IAC1BA,GACF4C,EAAgB5C,GAEF,MAAhB2C,GAAgCA,GAAc,IA/JpDzF,EAAQ8F,OAAM,SACXC,SAAQ,IAAMpD,EAAiBK,OAAOhD,IAAS,EA0J9CgG,CAAsBhG,GAMfqF,EAAa9E,EAAMP,EAAS2E,GAAkB,EACvD,CAhJkB,IAAC9E,EAiJnB,OAAOwF,EAAa9E,EAAMiF,EAAgBb,EAAiB,EAiBvDsB,EAAgB,CAAC1F,EAAM2F,KAC3B,MAAMzC,EAAYS,EAAa3D,GAC/B,IAAK2F,GAASzC,EAAW,CACvB,GAAIG,EAAWU,IAAI/D,GACjB,OAAOkD,EAET,GAAI0C,MAAMC,KAAK3C,EAAUqB,GAAGuB,OAAM,EAAE9D,EAAGnE,MACrC,GAAImE,IAAMhC,EACR,OAAO,EAET,MAAM0E,EAASgB,EAAc1D,GAC7B,OAAO0C,IAAW7G,GAAK+E,EAAiB8B,EAAQ7G,EAAE,IAElD,OAAOqF,CAEX,CACA,MAAMkB,EAAmC,IAAIb,IAC7C,IAAIwC,GAAS,EACb,MAAMC,EAAUhE,IACd,GAAID,EAAW/B,EAAMgC,GAAI,CACvB,MAAMiE,EAAUtC,EAAa3B,GAC7B,GAAIiE,EAEF,OADA7B,EAAiBhD,IAAIY,EAAGiE,GACjBhD,EAAgBgD,GAEzB,GAAI/D,EAAgBF,GAElB,OADAoC,EAAiBhD,IAAIY,OAAG,GACjBA,EAAEL,KAEX,MAAM,IAAIR,MAAM,eAClB,CACA,MAAMuD,EAASgB,EAAc1D,GAE7B,OADAoC,EAAiBhD,IAAIY,EAAG0C,GACjBzB,EAAgByB,EAAO,EAEhC,IAAIwB,EACAC,EACJ,MAAMjH,EAAU,CACd,UAAIkH,GAIF,OAHKF,IACHA,EAAa,IAAIG,iBAEZH,EAAWE,MACpB,EACA,WAAID,GAcF,OAb2EhE,EAAuBnC,IAChG2E,QAAQC,KAAK,wDAEVuB,GAAWhE,EAAuBnC,KACrCmG,EAAU,IAAIjF,KAIZ,GAH0E6E,GACxEpB,QAAQC,KAAK,8CAEVmB,EACH,OAAOO,EAAUtG,KAASkB,EAC5B,GAGGiF,CACT,GAEF,IACE,MAAMlB,EAAiBjF,EAAKsB,KAAK0E,EAAQ9G,GACzC,OAAO8F,EACLhF,EACAiF,EACAb,GACA,IAAoB,MAAd8B,OAAqB,EAASA,EAAWK,SAEnD,CAAE,MAAOC,GACP,MArFiB,EAACxG,EAAMwG,EAAOpC,KACjC,MAAMN,EAAgBH,EAAa3D,GAC7BmE,EAAgB,CACpBI,GAAqB,MAAjBT,OAAwB,EAASA,EAAcS,IAAsB,IAAIhB,IAC7EzD,GAKF,OAHIsE,GACFF,EAAmBlE,EAAMmE,EAAeC,GAEtCtB,EAAiBgB,EAAeK,IAAkBL,EAAcS,IAAMJ,EAAcI,EAC/ET,GAETF,EAAa5D,EAAMmE,GACZA,EAAa,EAwEXsC,CAAazG,EAAMwG,EAAOpC,EACnC,CAAE,QACA2B,GAAS,CACX,GAUIW,EAAiB,CAAC1G,EAAM2G,KAAaA,EAAQC,EAAE/B,QAAU8B,EAAQ/I,EAAEiH,MAA2B,IAAnB8B,EAAQ/I,EAAEiH,MAAc8B,EAAQ/I,EAAEmG,IAAI/D,IAOjH6G,EAAuB7G,IAC3B,MAWM8G,EAAiB,IAAIlB,MACrBmB,EAA8B,IAAIrD,IAClCsD,EAASjJ,IACb,IAAIgJ,EAAYhD,IAAIhG,GAApB,CAGAgJ,EAAYE,IAAIlJ,GAChB,IAAK,MAAMmJ,IAlBS,CAAClF,IACrB,IAAIvD,EACJ,MAAM0I,EAAa,IAAIzD,IAAgC,OAA3BjF,EAAK4E,EAAW7C,IAAIwB,SAAc,EAASvD,EAAGb,GAO1E,OANA0F,EAAWmB,SAAQ,CAAC2C,EAAGC,KACrB,IAAIC,GACqC,OAApCA,EAAM3D,EAAa0D,SAAwB,EAASC,EAAI/C,EAAER,IAAI/B,KACjEmF,EAAWF,IAAII,EACjB,IAEKF,CAAU,EASDI,CAAcxJ,GACxBA,IAAMmJ,GACRF,EAAME,GAGVJ,EAAeU,KAAKzJ,EAPpB,CAOsB,EAExBiJ,EAAMhH,GACN,MAAMyH,EAA+B,IAAI/D,IAAI,CAAC1D,IAC9C,IAAK,IAAIlC,EAAIgJ,EAAe7I,OAAS,EAAGH,GAAK,IAAKA,EAAG,CACnD,MAAMkE,EAAI8E,EAAehJ,GACnBgG,EAAgBH,EAAa3B,GACnC,IAAK8B,EACH,SAEF,IAAI4D,GAAiB,EACrB,IAAK,MAAMC,KAAO7D,EAAcS,EAAEqD,OAChC,GAAID,IAAQ3F,GAAKyF,EAAa1D,IAAI4D,GAAM,CACtCD,GAAiB,EACjB,KACF,CAEF,GAAIA,EAAgB,CAClB,MAAMvD,EAAgBuB,EAAc1D,GAAG,GAClCY,EAAiBkB,EAAeK,IACnCsD,EAAaR,IAAIjF,EAErB,CACF,GAEI6F,EAAiB,CAAC7H,KAASkB,KAC/B,IAAI6E,GAAS,EACb,MAyBM+B,EAAS9H,EAAKuB,OAzBJS,GAAMiB,EAAgByC,EAAc1D,MACrC,CAACA,KAAM+F,KACpB,IAAIC,EACJ,GAAIjG,EAAW/B,EAAMgC,GAAI,CACvB,IAAKE,EAAgBF,GACnB,MAAM,IAAIb,MAAM,qBAElB,MAAM2C,EAAgBH,EAAa3B,GAC7BmC,EAAgBa,EAAsBhD,EAAG+F,EAAM,IAChDnF,EAAiBkB,EAAeK,IACnC0C,EAAoB7E,EAExB,MACEgG,EAAIH,EAAe7F,KAAM+F,GAE3B,IAAKhC,EAAQ,CACX,MAAMkC,EAAUC,IAEd1E,EAAmBiB,SAChBmC,GAAMA,EAAE,CAAEuB,KAAM,cAAeF,aAGtC,CACA,OAAOD,CAAC,MAEmC9G,GAE7C,OADA6E,GAAS,EACF+B,CAAM,EAETxB,EAAY,CAACtG,KAASkB,KAC1B,MAAM4G,EAASD,EAAe7H,KAASkB,GACjC+G,EAAUC,IAMhB,OAJE1E,EAAmBiB,SAChBmC,GAAMA,EAAE,CAAEuB,KAAM,QAASF,cAGvBH,CAAM,EAETM,EAAY,CAACpI,EAAMqI,EAAkBC,KACzC,IAAI7J,EACJ,MAAM8J,EAAQD,GAAgB,GACD,OAA5B7J,EAAKkF,EAAa3D,KAA0BvB,EAAG8F,EAAEE,SAAQ,CAAC2C,EAAGpF,KAC5D,MAAMwG,EAAWnF,EAAW7C,IAAIwB,GAC5BwG,EACFA,EAAS5K,EAAEqJ,IAAIjH,GAEXgC,IAAMhC,GACRoI,EAAUpG,EAAGhC,EAAMuI,EAEvB,IAEF7C,EAAc1F,GACd,MAAM2G,EAAU,CACd/I,EAAG,IAAI8F,IAAI2E,GAAoB,CAACA,IAChCzB,EAAmB,IAAIlD,KAMzB,GAJAL,EAAWjC,IAAIpB,EAAM2G,GAEnBlD,EAAawD,IAAIjH,GAEfmC,EAAuBnC,IAASA,EAAKyI,QAAS,CAChD,MAAM,QAAEA,GAAYzI,EACpBuI,EAAMf,MAAK,KACT,MAAMkB,EAAYD,GAAQ,IAAIvH,IAASoF,EAAUtG,KAASkB,KACtDwH,IACF/B,EAAQgC,EAAID,EACd,GAEJ,CAIA,OAHKJ,GACHC,EAAM9D,SAASmE,GAAMA,MAEhBjC,CAAO,EAEVkC,EAAe7I,IACnB,IAAIvB,EACJ,MAAMiK,EAA2C,OAA9BjK,EAAK4E,EAAW7C,IAAIR,SAAiB,EAASvB,EAAGkK,EAChED,GACFA,IAEFrF,EAAWZ,OAAOzC,GAEhByD,EAAahB,OAAOzC,GAEtB,MAAMkD,EAAYS,EAAa3D,GAC3BkD,GACEH,EAAoBG,IACtBZ,EAAcY,EAAUrD,GAE1BqD,EAAUqB,EAAEE,SAAQ,CAAC2C,EAAGpF,KACtB,GAAIA,IAAMhC,EAAM,CACd,MAAM2G,EAAUtD,EAAW7C,IAAIwB,GAC3B2E,IACFA,EAAQ/I,EAAE6E,OAAOzC,GACb0G,EAAe1E,EAAG2E,IACpBkC,EAAY7G,GAGlB,MAGF2C,QAAQC,KAAK,6CAA8C5E,EAC7D,EAEIqF,EAAoB,CAACrF,EAAMkD,EAAW4F,KAC1C,MAAMC,EAAS,IAAIrF,IAAIR,EAAUqB,EAAEqD,QAC7BoB,EAAsC,IAAItF,IAC5B,MAApBoF,GAAoCA,EAAiBrE,SAAQ,CAAC2C,EAAGpF,KAC/D,GAAI+G,EAAOhF,IAAI/B,GAEb,YADA+G,EAAOtG,OAAOT,GAGhBgH,EAAoB/B,IAAIjF,GACxB,MAAM2E,EAAUtD,EAAW7C,IAAIwB,GAC3B2E,GACFA,EAAQ/I,EAAE6E,OAAOzC,EACnB,IAEF+I,EAAOtE,SAASzC,IACd,MAAM2E,EAAUtD,EAAW7C,IAAIwB,GAC3B2E,EACFA,EAAQ/I,EAAEqJ,IAAIjH,GACLqD,EAAWU,IAAI/D,IACxBoI,EAAUpG,EAAGhC,EACf,IAEFgJ,EAAoBvE,SAASzC,IAC3B,MAAM2E,EAAUtD,EAAW7C,IAAIwB,GAC3B2E,GAAWD,EAAe1E,EAAG2E,IAC/BkC,EAAY7G,EACd,GACA,EAEEkG,EAAe,KACnB,IAAID,EAIJ,IAFEA,EAA0B,IAAIvE,IAEzBJ,EAAWuB,MAAM,CACtB,MAAMoE,EAAUrD,MAAMC,KAAKvC,GAC3BA,EAAW4F,QACXD,EAAQxE,SAAQ,EAAEzE,EAAM8D,MACtB,MAAMZ,EAAYS,EAAa3D,GAC/B,GAAIkD,EAAW,CACb,MAAMyD,EAAUtD,EAAW7C,IAAIR,GAC3B2G,GAAWzD,EAAUqB,KAAwB,MAAjBT,OAAwB,EAASA,EAAcS,IAC7Ec,EAAkBrF,EAAMkD,EAA4B,MAAjBY,OAAwB,EAASA,EAAcS,GAEhFoC,IAEF5D,EAAoBe,KAAmBlB,EAAiBkB,EAAeZ,KAAcJ,EAAiBgB,EAAeZ,MACrHyD,EAAQC,EAAEnC,SAAS0E,GAAaA,MAE9BlB,EAAQhB,IAAIjH,GAGlB,MACE2E,QAAQC,KAAK,+BACf,GAEJ,CAEE,OAAOqD,CACT,EAqBA,MAAO,CACLzH,IA5PcR,GAASiD,EAAgByC,EAAc1F,IA6PrDoB,IAAKkF,EACLzF,IAtBkB,CAACb,EAAMmJ,KAC3B,MAAMxC,EAxOQ,CAAC3G,IACf,IAAI2G,EAAUtD,EAAW7C,IAAIR,GAI7B,OAHK2G,IACHA,EAAUyB,EAAUpI,IAEf2G,CAAO,EAmOEyC,CAAQpJ,GAClBiI,EAAUC,IACVmB,EAAY1C,EAAQC,EAO1B,OANAyC,EAAUpC,IAAIkC,GAEZ3F,EAAmBiB,SAChBmC,GAAMA,EAAE,CAAEuB,KAAM,MAAOF,cAGrB,KACLoB,EAAU5G,OAAO0G,GA1OL,CAACnJ,IACf,MAAM2G,EAAUtD,EAAW7C,IAAIR,GAC3B2G,GAAWD,EAAe1G,EAAM2G,IAClCkC,EAAY7I,EACd,EAuOEsJ,CAAQtJ,GAENwD,EAAmBiB,SAASmC,GAAMA,EAAE,CAAEuB,KAAM,WAC9C,CACD,EAQCoB,oBAAqB,CAAC3C,EAAG4C,KACvB,GAAY,IAARA,EACF,MAAM,IAAIrI,MAAM,4CAGlB,OADAqC,EAAmByD,IAAIL,GAChB,KACLpD,EAAmBf,OAAOmE,EAAE,CAC7B,EAEH6C,sBAAuB,IAAMhG,EAAaiG,SAC1CC,mBAAqB3H,GAAMoB,EAAa5C,IAAIwB,GAC5C4H,gBAAkB5H,GAAMqB,EAAW7C,IAAIwB,GACvC6H,kBAAoBH,IAClB,IAAK,MAAO1J,EAAMiF,KAAmByE,EAC/BxH,EAAgBlC,KAClBgF,EAAsBhF,EAAMiF,GAC5B4B,EAAoB7G,IAGxB,MAAMiI,EAAUC,IAChB1E,EAAmBiB,SAChBmC,GAAMA,EAAE,CAAEuB,KAAM,UAAWF,aAC7B,EAQN,EAEH,IAAI6B,EAEsD,iBAA7CC,WAAWC,gCAClBD,WAAWC,8BAEbD,WAAWC,8BAAgC,EAG/C,MAAMC,EAAkB,KACjBH,IACoH,IAA7CC,WAAWC,+BACnFrF,QAAQC,KACN,gJAGJkF,EAAe3G,KAEV2G,E","sources":["webpack:///./node_modules/@redhat-cloud-services/frontend-components/esm/useChrome/useChrome.js","webpack:///./node_modules/jotai/esm/react.mjs","webpack:///./node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { useScalprum } from '@scalprum/react-core';\nvar useChrome = function (selector) {\n    var _a;\n    var state = useScalprum();\n    var chrome = ((_a = state.api) === null || _a === void 0 ? void 0 : _a.chrome) || {};\n    chrome = __assign(__assign({}, chrome), { initialized: state.initialized });\n    if (typeof selector === 'function') {\n        return selector(chrome);\n    }\n    return chrome;\n};\nexport default useChrome;\n//# sourceMappingURL=useChrome.js.map","'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(void 0);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n","let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(\n      keepPreviousDependencies ? nextAtomState.d : null\n    );\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(\n        atom,\n        nextAtomState,\n        nextDependencies,\n        keepPreviousDependencies\n      );\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const getDependents = (a) => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, true);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n    maybeUnmountAtomSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted && canUnmountAtom(a, mounted)) {\n        unmountAtom(a);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          const mounted = mountedMap.get(atom);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","selector","_a","state","useScalprum","chrome","api","initialized","StoreContext","createContext","useStore","options","store","useContext","isPromiseLike","x","then","use","promise","status","value","reason","v","e","useAtomValue","atom","valueFromReducer","storeFromReducer","atomFromReducer","rerender","useReducer","prev","nextValue","get","is","delay","useEffect","unsub","sub","setTimeout","useDebugValue","useSetAtom","useCallback","args","Error","set","keyCount","read","write","key","config","toString","init","defaultRead","defaultWrite","arg","isSelfAtom","a","unstable_is","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","cancelPromise","next","cancel","delete","resolvePromise","rejectPromise","isEqualAtomValue","b","isEqualAtomError","hasPromiseAtomValue","Promise","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingMap","Map","storeListenersRev2","mountedAtoms","Set","getAtomState","setAtomState","freeze","prevAtomState","has","resolve","reject","updateDependencies","nextAtomState","nextDependencies","keepPreviousDependencies","dependencies","d","changed","forEach","aState","console","warn","size","setAtomValue","orig","setAtomValueOrPromise","valueOrPromise","abortPromise","continuePromise","updatePromiseDependencies","mountDependencies","settled","catch","finally","registerCancelPromise","readAtomState","force","Array","from","every","isSync","getter","aState2","controller","setSelf","signal","AbortController","writeAtom","abort","error","setAtomError","canUnmountAtom","mounted","l","recomputeDependents","topsortedAtoms","markedAtoms","visit","add","m","dependents","_","pendingAtom","_a2","getDependents","push","changedAtoms","hasChangedDeps","dep","keys","writeAtomState","result","args2","r","flushed","flushPending","type","mountAtom","initialDependent","onMountQueue","queue","aMounted","onMount","onUnmount","u","f","unmountAtom","prevDependencies","depSet","maybeUnmountAtomSet","pending","clear","listener","addAtom","listeners","delAtom","dev_subscribe_store","rev","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","defaultStore","globalThis","__NUMBER_OF_JOTAI_INSTANCES__","getDefaultStore"],"sourceRoot":""}